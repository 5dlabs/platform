#!/bin/sh

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘                 IMPLEMENTATION TASK STARTING                 â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'

# Disable interactive Git prompts globally
export GIT_TERMINAL_PROMPT=0
export GIT_ASKPASS=/bin/true
export SSH_ASKPASS=/bin/true

# Setup authentication based on repository URL type
REPO_URL="{{repository_url}}"
if echo "$REPO_URL" | grep -q "^git@\|^ssh://"; then
  echo "SSH repository URL detected"
  USE_SSH=true
else
  echo "HTTPS repository URL detected"
  USE_SSH=false
fi

# SSH Authentication Setup
if [ "$USE_SSH" = "true" ]; then
  echo "=== SSH AUTHENTICATION SETUP ==="

    # Check if SSH key is mounted (Kubernetes secrets are read-only)
  if [ -f "/workspace/.ssh/id_ed25519" ]; then
    echo "âœ“ SSH private key found at /workspace/.ssh/id_ed25519"

    # Create writable SSH directory in home
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh

    # Copy SSH keys from read-only mount to writable location (with sudo if needed)
    if cp /workspace/.ssh/id_ed25519 ~/.ssh/id_ed25519 2>/dev/null; then
      echo "âœ“ Copied SSH private key"
    elif sudo cp /workspace/.ssh/id_ed25519 ~/.ssh/id_ed25519 2>/dev/null; then
      echo "âœ“ Copied SSH private key (with sudo)"
      sudo chown $(whoami):$(whoami) ~/.ssh/id_ed25519
    else
      echo "âŒ Failed to copy SSH private key - trying alternative approach"
      # Alternative: use the SSH key directly from the mount point
      export SSH_KEY_PATH="/workspace/.ssh/id_ed25519"
      # Create symlink instead of copy
      ln -sf /workspace/.ssh/id_ed25519 ~/.ssh/id_ed25519 2>/dev/null || echo "Warning: Could not create symlink"
    fi

    chmod 600 ~/.ssh/id_ed25519 2>/dev/null || echo "Warning: Could not set private key permissions"

    if [ -f "/workspace/.ssh/id_ed25519.pub" ]; then
      if cp /workspace/.ssh/id_ed25519.pub ~/.ssh/id_ed25519.pub 2>/dev/null; then
        echo "âœ“ Copied SSH public key"
      elif sudo cp /workspace/.ssh/id_ed25519.pub ~/.ssh/id_ed25519.pub 2>/dev/null; then
        echo "âœ“ Copied SSH public key (with sudo)"
        sudo chown $(whoami):$(whoami) ~/.ssh/id_ed25519.pub
      else
        ln -sf /workspace/.ssh/id_ed25519.pub ~/.ssh/id_ed25519.pub 2>/dev/null || echo "Warning: Could not copy/link public key"
      fi
      chmod 644 ~/.ssh/id_ed25519.pub 2>/dev/null || echo "Warning: Could not set public key permissions"
    fi

    # Add GitHub to known hosts
    ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Failed to add GitHub to known hosts"

    # Configure Git to use SSH instead of HTTPS for GitHub
    git config --global url."git@github.com:".insteadOf "https://github.com/"
    echo "âœ“ Configured Git to use SSH for GitHub URLs"

    # Test SSH connection
    echo "Testing SSH connection to GitHub..."
    ssh -T git@github.com 2>&1 | head -3 || echo "SSH test completed"

    echo "âœ“ SSH authentication configured successfully"
  else
    echo "âŒ SSH private key not found at /workspace/.ssh/id_ed25519"
    echo "   Expected SSH key secret to be mounted to /workspace/.ssh/"
    exit 1
  fi
else
  # HTTPS Authentication Setup
  echo "=== HTTPS AUTHENTICATION SETUP ==="

  # Use environment variables directly (they're mounted as secrets)
  if [ -n "$GITHUB_TOKEN" ] && [ -n "$GITHUB_USER" ]; then
    echo "âœ“ GitHub environment variables found"

    # Configure git user FIRST
    git config --global user.name "$GITHUB_USER"
    git config --global user.email "${GITHUB_USER}@users.noreply.github.com"

    # Disable interactive prompts for git operations
    git config --global credential.helper ""
    git config --global core.askPass ""

    # Create credentials file with proper format
    mkdir -p /root/.git-credentials-dir
    echo "https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com" > /root/.git-credentials
    chmod 600 /root/.git-credentials

    # Configure git to use the credentials file
    git config --global credential.helper 'store --file=/root/.git-credentials'

    # Also set up workspace-specific credentials (for compatibility)
    echo "https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com" > /workspace/.git-credentials
    chmod 600 /workspace/.git-credentials

    echo "âœ“ Git credentials configured for user: $GITHUB_USER"

  else
    echo "âŒ Missing GITHUB_TOKEN or GITHUB_USER environment variables"
    echo "   GITHUB_TOKEN present: $([ -n "$GITHUB_TOKEN" ] && echo "yes" || echo "no")"
    echo "   GITHUB_USER present: $([ -n "$GITHUB_USER" ] && echo "yes" || echo "no")"
    exit 1
  fi
fi

# =============================================================================
# GITHUB AUTHENTICATION TESTING
# =============================================================================
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                 GITHUB AUTHENTICATION TESTING                â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Test 1: Basic GitHub API access
echo "=== TEST 1: GitHub API Authentication ==="
if [ -n "$GITHUB_TOKEN" ]; then
  echo "Testing GitHub API access..."
  API_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/user)
  if echo "$API_RESPONSE" | grep -q '"login"'; then
    API_USER=$(echo "$API_RESPONSE" | grep '"login"' | sed 's/.*"login": *"\([^"]*\)".*/\1/')
    echo "âœ“ GitHub API authentication successful"
    echo "  Authenticated as: $API_USER"
  else
    echo "âŒ GitHub API authentication failed"
    echo "   Response: $API_RESPONSE"
    echo ""
    echo "ğŸš« ABORTING: Cannot proceed without GitHub API access"
    exit 1
  fi
else
  echo "âŒ No GITHUB_TOKEN available for API testing"
  exit 1
fi

# Test 2: Repository access permissions
echo ""
echo "=== TEST 2: Repository Access Verification ==="
REPO_URL="{{repository_url}}"
# Extract owner/repo from URL
if echo "$REPO_URL" | grep -q "github.com"; then
  REPO_PATH=$(echo "$REPO_URL" | sed 's|.*github.com[/:]||' | sed 's|\.git$||')
  echo "Testing repository access for: $REPO_PATH"

  REPO_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$REPO_PATH")
  if echo "$REPO_RESPONSE" | grep -q '"full_name"'; then
    echo "âœ“ Repository is accessible via API"

    # Check permissions
    PERMISSIONS=$(echo "$REPO_RESPONSE" | grep -o '"permissions":{[^}]*}' || echo "")
    if echo "$PERMISSIONS" | grep -q '"push":true'; then
      echo "âœ“ Push permissions confirmed"
    else
      echo "âš ï¸  WARNING: Push permissions may be limited"
      echo "   Permissions: $PERMISSIONS"
    fi
  else
    echo "âŒ Repository not accessible via API"
    echo "   Response: $REPO_RESPONSE"
    echo ""
    echo "ğŸš« ABORTING: Cannot access target repository"
    exit 1
  fi
else
  echo "âš ï¸  Non-GitHub repository detected, skipping API permission check"
fi

# Dual Repository Setup - Platform repo for docs, Target repo for implementation
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                 DUAL REPOSITORY SETUP                        â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Platform Repository Information (for task documentation)
PLATFORM_URL="{{platform_repository_url}}"
PLATFORM_BRANCH="{{branch}}"
PLATFORM_USER="{{github_user}}"

echo "=== PLATFORM REPOSITORY SETUP ==="
echo "Platform repo: $PLATFORM_URL"
echo "Platform branch: $PLATFORM_BRANCH"
echo "Platform user: $PLATFORM_USER"

# Target Repository Information (for implementation)
REPO_URL="{{repository_url}}"
REPO_BRANCH="{{branch}}"
GITHUB_USER="{{github_user}}"

echo "=== TARGET REPOSITORY SETUP ==="
echo "Target repo: $REPO_URL"
echo "Target branch: $REPO_BRANCH"
echo "Target user: $GITHUB_USER"

# 1. Clone Platform Repository (for docs)
echo "=== CLONING PLATFORM REPOSITORY ==="
if ! git clone "$PLATFORM_URL" platform-repo; then
    echo "âŒ Failed to clone platform repository: $PLATFORM_URL"
    exit 1
fi
cd platform-repo && git checkout "$PLATFORM_BRANCH" && cd /workspace
echo "âœ“ Platform repository cloned successfully"

# 2. Copy Current Task Documentation (Clean Previous Task Content)
echo "=== SETTING UP CURRENT TASK ==="

# Remove any previous task content to avoid confusion
rm -rf task/ 2>/dev/null

# Create clean task directory for current task only
mkdir -p task
if [ -d "platform-repo/.taskmaster/docs/task-{{task_id}}" ]; then
    cp platform-repo/.taskmaster/docs/task-{{task_id}}/task.md task/ 2>/dev/null || echo "âš ï¸  task.md not found"
    cp platform-repo/.taskmaster/docs/task-{{task_id}}/acceptance-criteria.md task/ 2>/dev/null || echo "âš ï¸  acceptance-criteria.md not found"
    cp platform-repo/.taskmaster/docs/task-{{task_id}}/architecture.md task/ 2>/dev/null || echo "âš ï¸  architecture.md not found"
    echo "âœ“ Task {{task_id}} documentation copied (previous task content cleaned)"
else
    echo "âš ï¸  Task {{task_id}} documentation directory not found in platform repo"
fi

# 3. MCP Client Configuration (now generated dynamically)
echo "âœ“ MCP client configuration will be copied from ConfigMap during file setup"

# 4. Target Repository Setup (Smart Detection & Cleanup)
echo "=== TARGET REPOSITORY OPERATIONS ==="
if [ -d "target-repo/.git" ]; then
    echo "=== EXISTING REPOSITORY DETECTED ==="
    cd target-repo

    # Cleanup Phase - Handle previous agent state
    echo "=== REPOSITORY CLEANUP ==="

    # Save current branch for logging
    CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
    echo "Found repository on branch: $CURRENT_BRANCH"

    # Reset any uncommitted changes
    git reset --hard HEAD 2>/dev/null || true
    git clean -fd 2>/dev/null || true

    # Check if we're retrying the same task
    FEATURE_BRANCH="feature/task-{{task_id}}-implementation"
    if [ "$CURRENT_BRANCH" = "$FEATURE_BRANCH" ]; then
        echo "=== CONTINUING EXISTING TASK {{task_id}} ==="
        # For task retry - preserve the feature branch but clean it up
        git reset --hard HEAD
        git clean -fd
        echo "Cleaned up existing feature branch for retry"
    else
        echo "=== STARTING NEW TASK {{task_id}} ==="
        # For new task - return to base branch and cleanup old feature branches
        git fetch origin
        git checkout "$REPO_BRANCH" 2>/dev/null || git checkout -b "$REPO_BRANCH" origin/"$REPO_BRANCH"
        git pull origin "$REPO_BRANCH"

        # Clean up old feature branches (keep last 3 for debugging)
        git branch | grep "feature/task-" | head -n -3 | xargs -r git branch -D 2>/dev/null || true

        # Create fresh feature branch for new task
        git checkout -b "$FEATURE_BRANCH"
        echo "Created fresh feature branch: $FEATURE_BRANCH"
    fi
else
    echo "=== CLONING FRESH TARGET REPOSITORY ==="
    if ! git clone "$REPO_URL" target-repo; then
        echo "âŒ Failed to clone target repository: $REPO_URL"
        exit 1
    fi
    cd target-repo

    # Create feature branch for this implementation
    git checkout -b "feature/task-{{task_id}}-implementation"
    echo "Created initial feature branch for task {{task_id}}"
fi

# 5. Set Working Directory
WORK_DIR="{{working_directory}}"
mkdir -p "$WORK_DIR" && cd "$WORK_DIR"
echo "âœ“ Set working directory: /workspace/target-repo/$WORK_DIR"

# 6. MCP Configuration Setup
echo "=== MCP CONFIGURATION SETUP ==="
cp /config/mcp.json /workspace/.mcp.json 2>/dev/null || echo "âš ï¸  mcp.json template not found"
# client-config.json already copied from platform repo in step 3

# Configure git user after successful clone
echo "=== POST-CLONE GIT CONFIGURATION ==="
# Fix dubious ownership issues
git config --global --add safe.directory /workspace/platform-repo
git config --global --add safe.directory /workspace/target-repo
echo "âœ“ Added repositories to safe directories"

git config --global user.name "$GITHUB_USER"
git config --global user.email "${GITHUB_USER}@users.noreply.github.com"
echo "âœ“ Configured git user: $GITHUB_USER"

# Copy ConfigMap files to working directory (AFTER repository clone)
echo "=== CONFIGMAP FILE SETUP ==="

# For implementation tasks, Claude works in the target repository service directory
CLAUDE_WORK_DIR="/workspace/target-repo/$WORK_DIR"

echo "Setting up files in Claude working directory: $CLAUDE_WORK_DIR"
cd "$CLAUDE_WORK_DIR"

# Copy all files from ConfigMap to working directory
if [ -d "/config" ]; then
  echo "Copying ConfigMap files to working directory..."

  # Copy markdown files (preserve existing CLAUDE.md memory)
  for md_file in /config/*.md; do
    if [ -f "$md_file" ]; then
      basename_file=$(basename "$md_file")
      if [ "$basename_file" = "CLAUDE.md" ]; then
        # Only copy CLAUDE.md if it doesn't already exist (preserve memory)
        if [ ! -f "$CLAUDE_WORK_DIR/CLAUDE.md" ]; then
          cp "$md_file" "$CLAUDE_WORK_DIR/"
          echo "âœ“ Created initial CLAUDE.md memory file"
        else
          echo "âœ“ Preserved existing CLAUDE.md memory file"
        fi
      else
        # Always update other markdown files (guidelines, etc.)
        cp "$md_file" "$CLAUDE_WORK_DIR/"
        echo "âœ“ Updated $basename_file"
      fi
    fi
  done

  # Set up Claude Code local settings (user-level settings)
  echo "=== CLAUDE CODE LOCAL SETTINGS ==="
  mkdir -p "$CLAUDE_WORK_DIR/.claude"
  chmod 755 "$CLAUDE_WORK_DIR/.claude"

  # Copy Claude settings as local settings
  if [ -f "/config/settings-local.json" ]; then
    cp /config/settings-local.json "$CLAUDE_WORK_DIR/.claude/settings.local.json"
    chmod 644 "$CLAUDE_WORK_DIR/.claude/settings.local.json"
    echo "âœ“ Copied settings-local.json to .claude/settings.local.json"
  else
    echo "âŒ ERROR: Claude settings template not found in ConfigMap!"
    echo "Expected: /config/settings-local.json"
    exit 1
  fi

  # Validate the settings JSON
  if jq empty "$CLAUDE_WORK_DIR/.claude/settings.local.json" 2>/dev/null; then
    echo "âœ“ Local settings JSON is valid"
    echo "âœ“ Model configuration, tools, and permissions are defined"

    echo ""
    echo "Local settings contents:"
    cat "$CLAUDE_WORK_DIR/.claude/settings.local.json" | jq . 2>/dev/null || cat "$CLAUDE_WORK_DIR/.claude/settings.local.json"
  else
    echo "âŒ Local settings JSON is invalid"
    cat "$CLAUDE_WORK_DIR/.claude/settings.local.json"
    exit 1
  fi

  # Copy all hook scripts (now prefixed with hooks- to comply with ConfigMap key constraints)
  echo "Copying hook scripts..."
  for hook_file in /config/hooks-*.sh; do
    if [ -f "$hook_file" ]; then
      # Extract the hook name (remove hooks- prefix) and copy to workspace
      hook_name=$(basename "$hook_file" | sed 's/^hooks-//')
      cp "$hook_file" "$CLAUDE_WORK_DIR/$hook_name"
      chmod +x "$CLAUDE_WORK_DIR/$hook_name"
      echo "âœ“ Copied hook: $hook_name"
    fi
  done
  # Check if any hooks were copied
  if ls "$CLAUDE_WORK_DIR"/*.sh >/dev/null 2>&1; then
    echo "âœ“ Hook scripts copied successfully"
  else
    echo "! No hook scripts found to copy"
  fi

  echo "âœ“ ConfigMap files copied to $CLAUDE_WORK_DIR"
else
  echo "âš ï¸  Warning: /config directory not found (ConfigMap not mounted?)"
fi

echo '=== WORKSPACE VALIDATION ==='

# Check for required files in Claude's working directory
MISSING_FILES=""
REQUIRED_FILES="CLAUDE.md"

echo "Checking for required files..."
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
    MISSING_FILES="$MISSING_FILES $file"
  else
    echo "âœ“ Found: $CLAUDE_WORK_DIR/$file"
    # Show file size for verification
    size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
    echo "  File size: $size bytes"
  fi
done

# Check git repository (REQUIRED for implementation tasks)
if [ ! -d "/workspace/target-repo/.git" ]; then
  echo "âœ— CRITICAL ERROR: No target git repository found!"
  MISSING_FILES="$MISSING_FILES git-repository"
else
  echo "âœ“ Found: target git repository"
fi

# If any files are missing, abort
if [ -n "$MISSING_FILES" ]; then
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "â•‘                 WORKSPACE VALIDATION FAILED                  â•‘"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "The following required files are missing:"
  for missing in $MISSING_FILES; do
    case "$missing" in
      "CLAUDE.md")
        echo "  âŒ $missing - Main task instructions for Claude"
        ;;
      "git-repository")
        echo "  âŒ $missing - Required for committing implementation changes"
        ;;
      *)
        echo "  âŒ $missing"
        ;;
    esac
  done
  echo ""
  echo "These files should have been created by the ConfigMap setup process."
  echo "Claude will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo "âœ“ All required files present. Workspace is valid."

echo '=== IMPLEMENTATION TASK DIAGNOSTICS ==='
echo "Project directory: $CLAUDE_WORK_DIR"
echo "Project directory contents:"
ls -la "$CLAUDE_WORK_DIR"
echo ""

# Show git status
echo "Git status:"
git status 2>/dev/null || echo "Git status unavailable"
echo ""

echo '=== CLAUDE EXECUTION ==='

# Export necessary variables
export SERVICE_NAME="{{service}}"
export TASK_ID="{{task_id}}"

# Change to project directory before running Claude
cd "$CLAUDE_WORK_DIR"
echo "Changed to directory: $(pwd)"

# Verify we're in the correct directory and have required files
echo "=== WORKING DIRECTORY VERIFICATION ==="
echo "Current working directory: $(pwd)"
echo "Expected directory: $CLAUDE_WORK_DIR"
if [ "$(pwd)" != "$CLAUDE_WORK_DIR" ]; then
  echo "âŒ ERROR: Failed to change to correct working directory!"
  echo "Attempting to change directory again..."
  cd "$CLAUDE_WORK_DIR" || exit 1
  echo "âœ“ Successfully changed to: $(pwd)"
fi

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    CLAUDE CONTENT PREVIEW                     â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

echo "=== 1. LOCAL SETTINGS (.claude/settings.local.json) ==="
if [ -f ".claude/settings.local.json" ]; then
  echo "Local settings contents:"
  cat ".claude/settings.local.json" | jq . 2>/dev/null || cat ".claude/settings.local.json"
else
  echo "âŒ Local settings file not found!"
fi
echo ""

echo "=== 2. CLAUDE TASK INSTRUCTIONS (CLAUDE.md) ==="
if [ -f "CLAUDE.md" ]; then
  echo "Full CLAUDE.md contents:"
  cat "CLAUDE.md"
else
  echo "âŒ CLAUDE.md not found!"
fi
echo ""

echo "=== 3. ADDITIONAL MARKDOWN FILES ==="
echo "Other markdown files in working directory:"
for md_file in *.md; do
  if [ -f "$md_file" ] && [ "$md_file" != "CLAUDE.md" ]; then
    echo ""
    echo "--- FILE: $md_file ---"
    cat "$md_file"
    echo ""
  fi
done
echo ""

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    END CONTENT PREVIEW                        â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Build Claude command
CLAUDE_CMD="{{command}} -p --output-format stream-json --verbose"

# Add model flag if specified and different from default
{{#if model_override}}
CLAUDE_CMD="$CLAUDE_CMD --model {{model}}"
echo "Using specified model: {{model}}"
{{/if}}

# Add retry flag if this is a retry attempt
{{#if is_retry}}
CLAUDE_CMD="$CLAUDE_CMD --continue"
echo 'Adding --continue flag for attempt {{attempts}}'
{{/if}}

echo "=== 4. ENVIRONMENT VARIABLES ==="
echo "Environment variables Claude will see:"
env | grep -E '^(CLAUDE|ANTHROPIC|OTEL|SERVICE_NAME|TASK_ID|GITHUB|NODE_ENV|DISABLE)' | sort || echo "No relevant env vars found"
echo ""

echo "=== 5. WORKING DIRECTORY STATE ==="
echo "Current working directory: $(pwd)"
echo "Directory contents:"
ls -la
echo ""

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "â•‘                    STARTING CLAUDE EXECUTION                  â•‘"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"
echo "Starting Claude execution..."
echo "=========================="

# Load the prompt template content
PROMPT="{{prompt_content}}"

# Enhanced System Prompt for Production-Grade Paranoid Verification
BASE_SYSTEM_PROMPT="You are a highly capable, highly critical, somewhat paranoid, super senior principal Rust engineer.

CRITICAL: You are implementing code that MUST work in production. Be extremely paranoid about declaring success.

MANDATORY VERIFICATION REQUIREMENTS:
Before marking ANY task as complete, you MUST:
- Execute the actual functionality in a real environment
- Show the user the exact output/logs proving it works
- If you cannot test it, explicitly state \"IMPLEMENTATION UNVERIFIED\" and STOP working on dependent tasks

NEVER say you are \"done\" or \"completed\" unless you have:
1. Actually executed your code in a real environment
2. Observed it working correctly with your own eyes
3. Run regression tests and seen them pass
4. Verified all edge cases and error conditions

EVIDENCE REQUIREMENT:
When claiming something works, you MUST provide one of:
- Actual execution logs showing success
- Test output demonstrating the functionality
- Live demonstration of the feature working
- Explicit statement: \"Cannot verify - implementation incomplete\"

FORWARD PROGRESS BLOCKER:
NEVER proceed to the next task if the current one is unverified. Untested code is broken code until proven otherwise.

COGNITIVE CHECK:
Before saying \"done\" or \"complete\", ask yourself: \"If this breaks in production, can I point to specific evidence that it was working?\" If no, it's not done.

If you cannot test in a real environment, explicitly state what testing you were unable to perform and why the implementation should be considered incomplete until proper testing is done.

As a senior principal engineer, you understand that production failures are extremely costly.
Err on the side of being too cautious rather than too confident.
Apply the highest standards of code quality, testing, and verification."

{{#if prompt_modification}}
# Prompt modification for retry attempt
PROMPT_MODIFICATION="{{prompt_modification}}"
PROMPT_MODE="{{prompt_mode}}"

if [ "$PROMPT_MODE" = "replace" ]; then
  # Replace mode: Use prompt modification as complete system prompt
  SYSTEM_PROMPT="$PROMPT_MODIFICATION"
  echo "Using replacement system prompt for retry"
else
  # Append mode: Add prompt modification to base system prompt
  SYSTEM_PROMPT="$BASE_SYSTEM_PROMPT

=== RETRY GUIDANCE ===
$PROMPT_MODIFICATION
======================"
  echo "Using appended system prompt for retry"
fi
{{else}}
# No prompt modification - use base system prompt
SYSTEM_PROMPT="$BASE_SYSTEM_PROMPT"
echo "Using standard system prompt"
{{/if}}

echo "=== 6. FINAL EXECUTION ==="
echo "CLAUDE.md (project memory): Will be automatically loaded by Claude"
echo "Prompt (task instruction): $PROMPT"
{{#if prompt_modification}}
echo "System Prompt: Modified for retry (mode: {{prompt_mode}})"
{{else}}
echo "System Prompt: Standard paranoid verification requirements"
{{/if}}
echo "=== END EXECUTION INFO ==="
echo ""

exec $CLAUDE_CMD --append-system-prompt "$SYSTEM_PROMPT" "$PROMPT"

echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
echo 'â•‘                 IMPLEMENTATION TASK COMPLETE                 â•‘'
echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
---
name: Continuous Integration

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_BASE: ${{ github.repository }}

jobs:
  # Change detection job
  changes:
    runs-on: ubuntu-latest
    outputs:
      controller: ${{ steps.filter.outputs.controller }}
      taskrun: ${{ steps.filter.outputs.taskrun }}
      infra: ${{ steps.filter.outputs.infra }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            controller:
              - 'controller/**'
              - '!controller/**/*.md'
            taskrun:
              - 'controller/core/src/controllers/task_controller/**'
              - 'controller/core/src/crds/**'
              - 'infra/test-resources/crds/**'
            infra:
              - 'infra/**'
              - '.github/workflows/**'

  # Parallel linting and testing
  lint-rust:
    needs: changes
    if: needs.changes.outputs.controller == 'true' || needs.changes.outputs.taskrun == 'true' || github.event_name == 'push'
    runs-on: ubuntu-22.04
    outputs:
      format-needed: ${{ steps.format-check.outputs.format-needed }}
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: controller -> target
          shared-key: "rust-cache-ci"

      - name: Auto-format code
        id: format-check
        working-directory: ./controller
        run: |
          echo "ðŸ”§ Running cargo fmt to ensure consistent formatting..."
          if ! cargo fmt --all -- --check; then
            echo "ðŸ“ Formatting issues detected - applying auto-format..."
            cargo fmt --all
            echo "format-needed=true" >> $GITHUB_OUTPUT
            echo "âœ… Code formatting automatically fixed"
          else
            echo "format-needed=false" >> $GITHUB_OUTPUT
            echo "âœ… Code formatting is already correct"
          fi

      - name: Run Clippy
        working-directory: ./controller
        run: cargo clippy --all-targets --all-features -- -D warnings

  # Commit formatting changes (runs on push events when formatting was needed)
  commit-format-changes:
    needs: [changes, lint-rust]
    if: always() && needs.lint-rust.outputs.format-needed == 'true' && github.event_name == 'push'
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          # Use a token that can bypass branch protection for auto-formatting
          token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: Auto-format Rust code
        working-directory: ./controller
        run: |
          echo "ðŸ”§ Auto-formatting Rust code..."
          cargo fmt --all

      - name: Check for changes
        id: changes
        run: |
          if git diff --quiet; then
            echo "No changes after formatting"
            echo "has-changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected after formatting"
            echo "has-changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push changes
        if: steps.changes.outputs.has-changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add -A
          git commit -m "ðŸ”§ Auto-format Rust code

          This commit was automatically generated by the CI pipeline
          to fix formatting issues detected by cargo fmt.

          [skip ci]"
          git push

  test-rust:
    needs: changes
    if: needs.changes.outputs.controller == 'true' || needs.changes.outputs.taskrun == 'true' || github.event_name == 'push'
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: controller -> target
          shared-key: "rust-cache-ci"

      - name: Run tests
        working-directory: ./controller
        run: cargo test --all-features --all-targets

  # Integration tests
  integration-tests:
    needs: [changes, lint-rust, test-rust]
    if: |
      always() && !cancelled() && 
      (needs.changes.outputs.controller == 'true' || 
       needs.changes.outputs.taskrun == 'true' || 
       needs.changes.outputs.infra == 'true' ||
       github.event_name == 'push')
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4

      - name: Cache kubectl
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/kubectl
          key: kubectl-ci-${{ runner.os }}-1.30.0

      - name: Create Kind cluster
        uses: helm/kind-action@v1.8.0
        with:
          cluster_name: platform-test
          kubectl_version: v1.30.0
          wait: 120s
          verbosity: 1

      - name: Test Helm Chart Structure
        run: |
          echo "ðŸŽ¯ Testing controller Helm chart..."

          # Install Helm
          curl -fsSL https://get.helm.sh/helm-v3.14.0-linux-amd64.tar.gz | tar xz
          sudo mv linux-amd64/helm /usr/local/bin/
          helm version

          # Lint the Helm chart
          helm lint ./infra/charts/controller

          # Test template generation with different values
          echo "ðŸ“‹ Testing default values..."
          helm template controller ./infra/charts/controller \
            --set argo.enabled=false > /tmp/default.yaml
          kubectl --dry-run=client apply -f /tmp/default.yaml

          echo "ðŸ“‹ Testing with secrets..."
          helm template controller ./infra/charts/controller \
            --set argo.enabled=false \
            --set secrets.anthropicApiKey="test-key" \
            --set secrets.githubToken="test-token" > /tmp/with-secrets.yaml
          kubectl --dry-run=client apply -f /tmp/with-secrets.yaml

          echo "âœ… Helm chart validation passed!"

      - name: Deploy test resources
        run: |
          # Create test namespace
          kubectl create namespace test-platform

          # Install CRD definitions first
          echo "ðŸ—ï¸  Installing CRD definitions..."
          kubectl apply -f infra/charts/controller/crds/

          # Create mock secrets for GitHub App authentication (required by CRDs)
          echo "ðŸ” Creating mock secrets for GitHub App..."
          kubectl create secret generic github-app-morgan-5dlabs \
            --namespace=test-platform \
            --from-literal=private-key="mock-private-key" \
            --from-literal=app-id="123456" || true
          
          # Create mock API key secret
          kubectl create secret generic anthropic-api-key \
            --namespace=test-platform \
            --from-literal=api-key="mock-api-key" || true

          # Apply test CodeRun and DocsRun instances
          echo "ðŸ§ª Applying test CRD instances..."
          kubectl apply -f infra/test-resources/crds/ -n test-platform || true
          
          # Wait a moment for resources to be created
          sleep 5

      - name: Verify CRD deployment
        run: |
          echo "ðŸ” Verifying CRD definitions..."
          kubectl get crd coderuns.agents.platform
          kubectl get crd docsruns.agents.platform
          
          echo "ðŸ” Verifying CRD instances..."
          kubectl get coderuns,docsruns -n test-platform
          
          echo "ðŸ” Describing test instances..."
          kubectl describe coderun test-coderun-ci -n test-platform || true
          kubectl describe docsrun test-docsrun-ci -n test-platform || true

  # Security scanning (non-blocking)
  security-scan:
    needs: changes
    if: github.event_name == 'push'  # Only on main branch
    runs-on: ubuntu-latest
    continue-on-error: true  # Non-blocking
    steps:
      - uses: actions/checkout@v4

      - name: Cache Trivy database
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ runner.os }}-${{ github.run_id }}
          restore-keys: |
            trivy-db-${{ runner.os }}-

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.30.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          cache-dir: ~/.cache/trivy

      - name: Upload Trivy scan results
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results
          path: trivy-results.sarif

      - name: Cache cargo-audit
        uses: actions/cache@v4
        id: cargo-audit-cache
        with:
          path: ~/.cargo/bin/cargo-audit
          key: cargo-audit-${{ runner.os }}-0.21.2

      - name: Install cargo-audit
        if: steps.cargo-audit-cache.outputs.cache-hit != 'true'
        run: cargo install cargo-audit --version 0.21.2

      - name: Rust security audit
        working-directory: ./controller
        run: cargo audit || true  # Non-blocking

  # Test coverage reporting (non-blocking)
  test-coverage:
    needs: changes
    if: needs.changes.outputs.controller == 'true' || needs.changes.outputs.taskrun == 'true' || github.event_name == 'push'
    runs-on: ubuntu-22.04
    continue-on-error: true  # Non-blocking
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: controller -> target
          shared-key: "rust-cache-ci"

      - name: Cache cargo-llvm-cov
        uses: actions/cache@v4
        id: cargo-llvm-cov-cache
        with:
          path: ~/.cargo/bin/cargo-llvm-cov
          key: cargo-llvm-cov-${{ runner.os }}-0.6.8

      - name: Install cargo-llvm-cov
        if: steps.cargo-llvm-cov-cache.outputs.cache-hit != 'true'
        run: cargo install cargo-llvm-cov --version 0.6.8

      - name: Generate test coverage
        working-directory: ./controller
        run: |
          echo "ðŸ“Š Generating test coverage report..."
          cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info || true
          cargo llvm-cov --all-features --workspace --html --output-dir coverage-html || true

          # Generate summary
          echo "## Test Coverage Summary" > coverage-summary.md
          echo "" >> coverage-summary.md
          if [ -f "lcov.info" ]; then
            COVERAGE=$(grep -E "^LF:|^LH:" lcov.info | awk -F: '{if($1=="LF") lf+=$2; if($1=="LH") lh+=$2} END {if(lf>0) printf "%.1f", (lh/lf)*100; else print "0.0"}')
            echo "ðŸ“Š **Overall Coverage**: ${COVERAGE}%" >> coverage-summary.md
            echo "Coverage: ${COVERAGE}%"
          else
            echo "âš ï¸ **Coverage**: Could not generate coverage report" >> coverage-summary.md
          fi

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-reports
          path: |
            controller/lcov.info
            controller/coverage-html/
            controller/coverage-summary.md